module main // Every source file must specify it's own module

/**
 * Grouped declarations 
 * New in COME: Syntactic symmetry across 4 keywords: const, import, export, alias.
 */
const PI = 3.14

// const enum: Support for multi-item and auto-incrementing enums
const ( 
    RED = enum,
    YELLOW,
    GREEN,
    UNKNOWN,
    HL_RED = enum(8),
    HL_YELLOW,
    HL_GREEN,  //tolerate extra ,
)

import (std, string) //multi items in one line

// multi items in multi lines
// Any variable and function is local until exported
export (
    PI, 
    Point, 
    add
)

// alias: Unified syntax for typedefs and defines
alias (
    tcpport_t = ushort,           // Alias as typedef
    Point = struct Point,         // Alias as typedef
    MAX_ARRAY = 5,                // Alias as constant define
    SQUARE(x) = ((x) * (x))       // Alias as macro define
)

// Module variable: Local to module unless exported
int module_arr[]

// Union: Standard C-style memory overlap
union TwoBytes {
    short signed_s
    ushort unsigned_s
    byte first_byte
}

// Struct: Standard composite type
struct Point {
    int x
    int y
}

// Struct with networking-style data
struct TCP_ADDR {
    tcpport_t portnumber
    byte ipaddr[16]
}

/**
 * STRUCT METHODS
 * New in COME: Define behavior directly on structs.
 * 'self' is a new keyword representing the instance pointer.
 */
byte TCP_ADDR.nport() {
    return (byte)self.portnumber 
}

int main(string args) {
    struct TCP_ADDR addr

    /**
     * HEADERED BUFFER METHODS
     * New in COME: Strings and arrays are no longer raw pointers.
     * .length() and .toi() are safe methods provided by the headered model.
     */
    if (args.length() > 2) {
        // .toi() is a string method replacing C's atoi()
        addr.portnumber = (ushort)args[2].toi()
        
        // .cpy() replaces memcpy() with a bounds-checked operation
        addr.ipaddr.cpy(args[1].byte_array())
    } else {
        std.out.printf("Usage: %s <ip> <port>\n", args[0])
    }

    return demo()
}

// Function prototype
int add(int a, int b)

void demo_types() {
    // Primitive types
    byte c1 = 'A'
    int i = 42
    long l = 1000L
    double d = 2.718
    bool flag = true
    
    // 'var' is a new keyword for block-scoped type inference
    var later_var = PI 

    /**
     * DYNAMIC MEMORY
     * Arrays are Headered Buffers. .resize() replaces malloc/realloc.
     */
    int arr[MAX_ARRAY] = {1, 2, 3, 4, 5}
    int scaled[] 
    scaled.resize(MAX_ARRAY) 

    struct Point p1 = { .x = 15, .y = 10 }
    
    union TwoBytes tb
    tb.unsigned_s = 0x1234

    std.out.printf("Types: %c, %d, %f, byte: %d\n", c1, i, d, tb.first_byte)
}

int demo() {
    demo_types()

    /**
     * SWITCH & FALLTHROUGH
     * 'fallthrough' is a new explicit keyword to allow case bleeding.
     */
    var color = YELLOW
    switch (color) {
        case RED:   std.out.printf("Red\n")
        case GREEN: std.out.printf("Green\n")
        case UNKNOWN:
            fallthrough 
        default:
            std.out.printf("Color code: %d\n", color)
    }

    /**
     * METADATA AWARENESS
     * .size() is a new method for O(1) retrieval of array length.
     */
    int dyn[]
    dyn.resize(3) 
    for (int n = 0; n < dyn.size(); n++) {
        dyn[n] = n * n
    }

    /**
     * MULTIPLE RETURN VALUES
     * New in COME: Return and destructure tuples directly.
     */
    var (sum, msg) = add_n_compare(10, 20)
    std.out.printf("%s: %d\n", msg, sum)

    // .free() is manual, but auto-called by .exit() at scope end (no leaks!)
    dyn.free() 
    
    return 0
}

int add(int a, int b) {
    return a + b
}

// Multi-return function definition
(int, string) add_n_compare(int a, int b) {
    return (a + b), (a > b) ? "Greater" : "Lesser/Equal"
}
